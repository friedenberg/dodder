#!/bin/bash -e

set -euo pipefail

# NATO phonetic alphabet levels in dependency order
LEVELS=("_" "alfa" "bravo" "charlie" "delta" "echo" "foxtrot" "golf" "hotel" "india" "juliett" "kilo" "lima" "mike" "november" "oscar" "papa" "quebec" "romeo" "sierra" "tango" "uniform" "victor" "whiskey" "xray" "yankee" "zulu")

DRY_RUN=false
VERBOSE=false

usage() {
  cat <<'EOF'
Usage: auto_reposition_packages [OPTIONS]

Automatically repositions Go packages in the NATO phonetic hierarchy based on their dependencies.

Rules:
- Packages in src/_ may only depend on stdlib or external packages
- Packages in src/alfa may depend on stdlib, external, or src/_
- Each subsequent level may depend on previous levels but not same/higher levels
- Packages in the same level may not depend on each other

Options:
    -n, --dry-run     Show what would be moved without actually moving
    -v, --verbose     Enable verbose output
    -h, --help        Show this help message

Examples:
    auto_reposition_packages           # Move packages as needed
    auto_reposition_packages -n        # Show what would be moved (dry run)
    auto_reposition_packages -v        # Verbose output while moving
EOF
}

log_verbose() {
  if [[ $VERBOSE == "true" ]]; then
    gum log -l debug "$*"
  fi
}

log_dry_run() {
  gum log -l debug "[DRY RUN] $*"
}

log_info() {
  gum log -l info "$*" >&2
}

log_error() {
  gum log -l error "$*" >&2
}

# Get the NATO level of a package path (e.g., "alfa/errors" -> "alfa")
get_package_level() {
  local pkg_path="$1"
  echo "${pkg_path%%/*}"
}

main() {
  # Parse command line arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    -n | --dry-run)
      DRY_RUN=true
      shift
      ;;
    -v | --verbose)
      VERBOSE=true
      shift
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *)
      log_error "Unknown option: $1"
      usage
      exit 1
      ;;
    esac
  done

  # Process each package
  while IFS= read -r line; do
    if [[ -z $line ]]; then
      continue
    fi

    # Parse the format: "<index>: <current_package_path>"
    if [[ $line =~ ^([0-9]+):\ (.+)$ ]]; then
      local required_index="${BASH_REMATCH[1]}"
      local current_pkg_path="${BASH_REMATCH[2]}"
      log_verbose "$line"

      # Get required level from NATO alphabet
      local required_level="${LEVELS[$required_index]}"

      # Get current level from package path
      local current_level
      current_level=$(get_package_level "$current_pkg_path")

      log_verbose "$required_index, $current_pkg_path, $required_level, $current_level"

      # Check if move is needed
      if [[ $required_level == "$current_level" ]]; then
        continue
      fi

      local pkg_name="${current_pkg_path#*/}" # Remove level prefix
      local src_path="src/$current_pkg_path"
      local dst_path="src/$required_level/$pkg_name"

      if [[ $DRY_RUN == "true" ]]; then
        echo "Would move: just codemod-go-move_package $src_path $dst_path"
      else
        log_info "Moving $src_path to $dst_path"
        just codemod-go-move_package "$src_path" "$dst_path" </dev/null
      fi
    fi
  done < <(./bin/list_deps | ./bin/sort_packages)
}

# Check if we're in the right directory
if [[ ! -f "go.mod" ]]; then
  log_error "This script must be run from the root of the Go module (directory with go.mod)"
  exit 1
fi

main "$@"
